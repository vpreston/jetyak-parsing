#!/usr/bin/env python

'''
Library for parsing datafiles generated by intruments onboard a ChemYak, including
Los Gatos Greenhouse Gas Analyzer (GGA), RBR CTD, SUNA Nitrate optical sensor, Aanderaa Optode,
and Air-Marine GPS and Weather station.

Maintainer: vpreston-at-{whoi, mit}-dot-edu
'''

import copy
import pandas as pd
import numpy as np

class Sensor(object):
    '''Parent class for all sensors, with shared methods'''
    def __init__(self, filepaths, bounds=None, trim_vals=None):
        self.source_path = filepaths #list of paths
        self.bounds = bounds
        self.trim_vals = trim_vals
        self.df = None
        self.offset = None
        self.effs = None
        self.peq = None

    def make_dataframe(self, header=0):
        ''' Construct a compiled dataframe for the sensor files provided '''
        df = pd.read_table(self.source_path[0], delimiter=',', header=header, engine='c')
        df.columns = [m.strip('  ') for m in df.columns]
        for m in self.source_path[1:]:
            temp = pd.read_table(m, delimiter=',', header=header, engine='c')
            temp.columns = [m.strip('  ') for m in temp.columns]
            df = df.append(temp, ignore_index=True)
        df = df.dropna()
        self.df = df

    def trim_up(self):
        ''' Perform any last trimming of the data according to trim or bound information '''
        if self.trim_vals is not None:
            for p in self.trim_vals:
                self.df = self.df[(self.df['Julian_Date'] >= p[0]) | (self.df['Julian_Date'] <= p[1])]
        if self.bounds is not None:
            self.df = self.df.drop(self.df[self.df.Julian_Date <= (self.bounds[0])].index)
            self.df = self.df.drop(self.df[self.df.Julian_Date >= (self.bounds[1])].index)

        self.df = self.df.dropna()

    def get_df(self):
        ''' Method for accessing the dataframe of the sensor directly '''
        return self.df

    def write_csv(self, save_path):
        ''' Method for writing the dataframe to file '''
        self.df.to_csv(save_path)

class GGA(Sensor):
    '''Class which specifically handles processing and reporting GGA data'''

    def set_characteristics(self, offset=-0.0034, effs=(1.0, 0.7), peq=495.):
        ''' Allows access to default extraction information '''
        self.offset = offset
        self.effs = effs
        self.peq = peq

    def clean_gga(self):
        ''' Method to construct the GGA dataframe, with all of the peculiarities of the
        sensor accounted for'''
        # get params
        if self.offset is not None:
            # a user has already set this, use those values
            pass
        else:
            # a user has not specified this, make the defaults
            self.set_characteristics()

        # make the initial frame, creating the df object
        self.make_dataframe(header=1)

        # create the time objects
        self.apply_time(self.offset)

        # clean up columns
        self.df.loc[:, 'CH4_ppm'] = self.df.apply(lambda x: x['[CH4]_ppm'], axis=1)
        self.df.loc[:, 'CO2_ppm'] = self.df.apply(lambda x: x['[CO2]_ppm'], axis=1)
        self.df = self.df.drop(['[CH4]_ppm', '[CO2]_ppm'], axis=1)

        # perform gas conversions
        # self.convert_CH4(eff=self.effs[0], peq=self.peq)
        # self.convert_CO2(eff=self.effs[1], peq=self.peq)

        # trim up
        self.trim_up()
        self.df = self.df.drop(self.df[self.df['CH4_ppm'] <= 0.0].index) #remove obvious outliers
        self.df = self.df.drop(self.df[self.df['CH4_ppm'] >= 100.0].index) #remove obvious outliers

    def apply_time(self, offset=0.0014):
        ''' Method to extract Julian Date and parse the time structure in the GGA file '''
        data = copy.copy(self.df)
        data.loc[:, 'Year'] = data['Time'].str.split(' ').str.get(2).str.split('/').str.get(2).astype('int')
        data.loc[:, 'Month'] = data['Time'].str.split(' ').str.get(2).str.split('/').str.get(0).astype('int')
        data.loc[:, 'Day'] = data['Time'].str.split(' ').str.get(2).str.split('/').str.get(1).astype('int')
        data.loc[:, 'Minute'] = data['Time'].str.split(' ').str.get(3).str.split(':').str.get(1).astype('float')
        data.loc[:, 'Hour'] = data['Time'].str.split(' ').str.get(3).str.split(':').str.get(0).astype('float')-1.00
        data.loc[:, 'Second'] = data['Time'].str.split(' ').str.get(3).str.split(':').str.get(2).astype('float')
        data.loc[:, 'Hour'] = data.apply((lambda x: float(x['Hour'] + int(x['Minute']/60.0))), axis=1)
        data.loc[:, 'Minute'] = data.apply((lambda x: float(x['Minute']%60)), axis=1)

        data = make_global_time(data)
        data = seconds_elapsed(data)

        data.loc[:, 'Julian_Date_cor'] = data.apply(lambda x: x['Julian_Date'] + offset, axis=1)
        data.loc[:, 'Julian_Date'] = data['Julian_Date_cor']
        self.df = data

    def convert_CH4(self, eff=0.03, peq=495., gppm=1.86):
        ''' Method to convert the raw ppm measurements from the GGA to compensated
        uatm units '''
        ui = peq * gppm / 1000.
        self.df.loc[:, 'CH4_uatm'] = self.df.apply(lambda x: ((x['CH4_ppm'] * peq / 1000. - ui) / eff + ui), axis=1)

    def convert_CO2(self, eff=0.70, peq=495., gppm=0.):
        ''' Method to convert the raw ppm measurements from the GGA to compensated
        uatm units '''
        ui = peq * gppm / 1000.
        self.df.loc[:, 'CO2_uatm'] = self.df.apply(lambda x: ((x['CO2_ppm'] * peq / 1000. - ui) / eff + ui), axis=1)

class CTD(Sensor):
    '''Class which specifically handles processing and reporting CTD data'''
    def clean_ctd(self):
        ''' Method to construct the CTD dataframe, with all of the peculiarities of the
        sensor accounted for'''

        #make the initial frame, creating the df object
        self.make_dataframe(header=0)

        # create the time objects
        self.apply_time()

        # trim up
        self.trim_up()

    def apply_time(self):
        ''' Create time objects'''
        data = copy.copy(self.df)
        data.loc[:, 'Year'] = data['Time'].str.split(' ').str.get(0).str.split('-').str.get(0).astype('int')
        data.loc[:, 'Month'] = data['Time'].str.split(' ').str.get(0).str.split('-').str.get(1).astype('int')
        data.loc[:, 'Day'] = data['Time'].str.split(' ').str.get(0).str.split('-').str.get(2).astype('int')
        data.loc[:, 'Hour'] = data['Time'].str.split(' ').str.get(1).str.split(':').str.get(0).astype('float')
        data.loc[:, 'Minute'] = data['Time'].str.split(' ').str.get(1).str.split(':').str.get(1).astype('float')
        data.loc[:, 'Second'] = data['Time'].str.split(' ').str.get(1).str.split(':').str.get(2).astype('float')
        data = make_global_time(data)
        data = seconds_elapsed(data)
        self.df = data

class Suna(Sensor):
    #TODO
    pass

class AirMar(Sensor):
    '''Class which specifically handles processing and reporting Airmar weather station data'''
    def make_dataframe(self, header=0):
        ''' Construct a compiled dataframe for the sensor files provided '''
        df = pd.read_table(self.source_path[0], delimiter=',', header=header, engine='c', dtype=object)
        df.columns = ['lat', 'lon', 'alt_M', 'geo_sep_M', 'COG_T', 'SOG_K', 'TOD', 'day', 'month',
                      'year', 'pressure_B', 'air_temp_C', 'wind_dir_T', 'wind_speed_M', 'reference',
                      'rateofturn', 'rel_wind_chill_c', 'theo_wind_chill_c', 'misc']
        for m in self.source_path[1:]:
            temp = pd.read_table(m, delimiter=',', header=header, engine='c', dtype=object)
            temp.columns = ['lat', 'lon', 'alt_M', 'geo_sep_M', 'COG_T', 'SOG_K', 'TOD', 'day',
                            'month', 'year', 'pressure_B', 'air_temp_C', 'wind_dir_T', 'wind_speed_M',
                            'reference', 'rateofturn', 'rel_wind_chill_c', 'theo_wind_chill_c', 'misc']
            df = df.append(temp, ignore_index=True)
        self.df = df

    def clean_airmar(self):
        ''' Method to construct the AirMar dataframe '''

        #make the initial frame, creating the df object
        self.make_dataframe(header=0)

        #create the time objects
        self.apply_time()

        # clean up lon/lat stamps
        self.df.loc[:, 'lon_mod'] = self.df.apply(lambda x: -dms2dd(x.lon), axis=1)
        self.df.loc[:, 'lat_mod'] = self.df.apply(lambda x: dms2dd(x.lat), axis=1)

        #trim up
        self.trim_up()

    def apply_time(self):
        ''' Create time objects '''
        data = copy.copy(self.df)
        data.loc[:, 'Year'] = data.apply(lambda x: int(x['year']), axis=1)
        data.loc[:, 'Month'] = data.apply(lambda x: int(x['month']), axis=1)
        data.loc[:, 'Day'] = data.apply(lambda x: int(x['day']), axis=1)
        data.loc[:, 'Hour'] = data.apply(lambda x: float(str(x['TOD'])[0:2]), axis=1)
        data.loc[:, 'Minute'] = data.apply(lambda x: float(str(x['TOD'])[2:4]), axis=1)
        data.loc[:, 'Second'] = data.apply(lambda x: float(str(x['TOD'])[4:]), axis=1)
        data = make_global_time(data)
        self.df = data

class Optode(Sensor):
    '''Class which specifically handles processing and reporting Airmar weather station data'''
    def set_characteristics(self, offset=-0.0034):
        ''' Allows access to default extraction information '''
        self.offset = offset

    def make_dataframe(self, header=0):
        ''' Construct a compiled dataframe for the sensor files provided '''
        df = pd.read_table(self.source_path[0], delimiter=',', header=header, engine='c')
        for m in self.source_path[1:]:
            temp =  pd.read_table(m, delimiter=',', header=header, engine='c')
            df = df.append(temp, ignore_index=True)
        self.df = df

    def clean_optode(self):
        ''' Method to construct the AirMar dataframe '''

        #make the initial frame, creating the df object
        self.make_dataframe(header=0)

        #create the time objects
        self.apply_time()

        #trim up
        self.trim_up()

    def apply_time(self):
        ''' Create time objects '''
        data = copy.copy(self.df)
        data.loc[:,'posixtime'] = data.apply(lambda x : x['posixtime']-14700.0, axis=1)
        data.loc[:,'Julian_Date'] = data.apply(lambda x : x.posixtime / 86400.0 + self.offset - 0.0416600001, axis=1)
        self.df = data

def calculate_julian_day(y, mo, d, h, mi, s):
    '''
    Takes a timestamp (hours in UTC) and converts to Julian Day via the appropriate formula.
    @input: year, month, day, hour, minute, seconds_total
    @output: julian day
    '''
    a = int((14 - mo)/12)
    ye = y + 4800 - a
    m = mo + 12*a - 3
    jdn = d + ((153*m + 2)/5) + 365*ye + ye/4 - ye/100 + ye/400 - 32045
    dl = (h-12)/24. + mi/1440. + s/86400.
    jd = int(jdn) + float(dl)
    return jd

def calculate_seconds_elapsed(df_row):
    '''
    An alternative to julian day, calculates the total seconds elapsed in the month of running.
    @input: row in a dataframe which contains day, hour, minute, and second fields
    @output: second that it is in the month
    '''
    seconds_total = df_row['Day']*24*60*60 + df_row['Hour']*60*60 + df_row['Minute']*60 + df_row['Second']
    return seconds_total

def seconds_elapsed(df):
    '''
    Adds a seconds elapsed column to the dataframe
    @input: dataframe
    @output: modifies dataframe without explicit output
    '''
    df.loc[:, 'Seconds_Elapsed'] = df.apply(lambda row: calculate_seconds_elapsed(row), axis=1)
    return df

def make_global_time(df):
    '''
    Creates a global time column based upon the initial timestamp of data collection
    @input: dataframe
    @output: none; dataframe rewritten with Julian_Data column
    '''
    df.loc[:, 'Julian_Date'] = df.apply(lambda row: calculate_julian_day(int(row.Year),
                                                                         int(row.Month),
                                                                         int(row.Day),
                                                                         float(row.Hour),
                                                                         float(row.Minute),
                                                                         float(row.Second)),axis=1)
    return df

def dms2dd(info):
    ''' method to convert between DMS to Decimal degrees'''
    if (float(info) > 10000 or str(info)[0] is '0') and len(info) > 1:
        degrees = float(str(info)[0:3])
        minutes = float(str(info)[3:]) / 60.0
        dd = degrees + minutes
    elif len(info) > 1:
        degrees = float(str(info)[0:2])
        minutes = float(str(info)[2:]) / 60.0
        dd = degrees + minutes
    else:
        return 0
    return dd
